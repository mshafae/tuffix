#!/usr/bin/env python3

# standard library

import sys

# packages

# local modules

# import tuffixlib # NOTE : being depreciated

from Tuffix.Configuration import BuildConfig, DEFAULT_BUILD_CONFIG
from Tuffix.Exceptions import *
from Tuffix.Commands import all_commands
from Tuffix.Status import *

# DRIVER CODE (ADAPTED FROM KEVIN WORTMAN)

def print_usage(build_config):
    if not (isinstance(build_config, BuildConfig)):
        raise ValueError

    print(
        'tuffix ' + str(build_config.version) + '\n\n' +
        'usage:\n\n' +
        '    tuffix <command> [argument...]\n\n' +
        'where <command> and [argument...] match one of the following:\n'
    )

    commands = all_commands(build_config)

    assert(len(commands) > 0) # for max to be defined
    name_width = 2 + max([len(cmd.name) for cmd in commands])

    for cmd in commands:
        print(cmd.name.ljust(name_width) + cmd.description)

    print('')


# Run the whole tuffix program. This is a self-contained function for unit
# testing purposes.
# build_config: a BuildConfig object
# argv: a list of commandline argument strings, such as sys.argv

def main(build_config, argv):
    if not (isinstance(build_config, BuildConfig) and
            isinstance(argv, list) and
            all([isinstance(arg, str) for arg in argv])):
            raise ValueError
    try :
        if len(argv) <= 1:
            raise UsageError('You must supply a command name')
        command_name = argv[1] # skip script name at index 0

        # find the AbstractCommand that the user specified
        command_object = None
        for cmd in all_commands(build_config):
            if cmd.name == command_name:
                command_object = cmd
                break

        # did we find a command?
        if not command_object:
            raise UsageError(f'unknown command "{command_name}"')

        # peel off the arguments
        arguments = argv[2:]

        # run the command...
        try:
            return command_object.execute(arguments)
        except MessageException as e:
            # general error message
            print(f'[ERROR]: {e.message}')
            return 1

    # commandline interface usage error
    except Exception as e:
    # except UsageError as e:
        print(f'[ERROR]: {e.message}')
        print_usage(build_config)
    # except EnvironmentError:
        # print('[]')



for line in status():
    print(line)
# if __name__ == '__main__':
    # # main(DEFAULT_BUILD_CONFIG, sys.argv)
